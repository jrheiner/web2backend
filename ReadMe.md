# BackEnd project

This is the server-side of our Web Engineering 2 Project.

The server is based on NodeJS express and is connected to a MongoDB database. 
In the config included in the submission, credentials to connect to a cloud-hosted database
are provided. However, it is also possible to run the server connection to a local MongoDB 
database.

For a general description of the project please refer to the ReadMe.md included in the submission directory directly. 
This file only covers parts specific to the BackEnd project

## Development environment
**To verify the development environment you can run `gulp dev`**, which will check if the config
file is in the correct directory, run eslint, and run mocha tests for the web services.

**To start the express server use `npm run start`**. 
Now http://localhost:3000/index.api.html should show a simple HTML page.


As part of `gulp dev` the jsdoc Documentation is built. You can find the HTML files in the `./docs` directory.
Right click the `index.html` and select `Run index.html` in Webstorm to view the documentation.

## Production deployment (of the entire app)
**Important**: This step can only be done after the dependencies for the FrontEnd project are installed.


To 'deploy' the Angular Application (FrontEnd project), run `gulp` in the terminal.
This will go through the following tasks: 
```
    checkConfig         - Check if config can be found in the correct directory
    runLinter           - Run eslint
    runTests            - Run mocha tests
    clean               - Remove old angular build files if available
    buildAngularCode    - Build FrontEnd project using 'ng build --prod'
    copyAngularCode     - Copy Angular build files into the express public directory
```
Starting the express server with `npm run start`, will now serve the angular app on the express server at http://localhost:3000/.

## Issues
If the tests when running the `gulp` command are failing because of a server timeout. Run `gulp build` to just build and copy the Angular files.
This happened on the company laptop due to some kind of restriction, all tests on private devices had no problem.

If gulp has missing permission to build the front end and copy files the manual step is to build the Angular project by using the 
`ng build --prod=true --base-href "/"` command and copying everything located in `dist/FrontEnd/**` (FrontEnd project)
into the express `public` (BackEnd project) directory.

## Remarks
Finally, some remarks on packages and technologies used. 

The project uses MongoDB through mongoose. The **database** is hosted on a 
[MongoDB shared M0 cluster](https://www.mongodb.com/pricing), this limits the database to 512 MB and 
functionality in the web control panel, but it is *free*. 

**Assets** generated by users through the web 
application are stored on [Cloudinary](https://cloudinary.com/), just like with MongoDB Atlas Cloudinary 
offers an unlimited free tier allowing a total of 25k transformations, 25 GB of managed storage or, 
25 GB of net viewing bandwidth every month. 
The reason why these two cloud providers were chosen are simply because they fulfilled the technical
requirements with a permanent free tier, with limitations that only have a small or no impact on the project.

Adding **user accounts** brought some challenges concerning security and session management. For example, some
API endpoints need to be protected as they should only be used by logged-in users. Additionally, it seemed impractical 
to just ask the user for credentials for every request. The project implements [JSON web tokens](https://jwt.io/) 
as session or authentication token. Such a token is created and signed by the server when a user logs in. The token
holds the user id as payload, this way the server can verify that a token is valid and directly identify the logged-in
user. During a session the server auth token is stored in session storage, however tampering with it will invalidate it, 
causing the server to reject the API request to a protected route. This makes it impossible for someone unauthenticated 
to make a protected API call, useless he/she has access to the server secret used to sign the token. Implementing this 
technology was a bit challenging at times but exciting for sure, and I think it tackles the challenges mentioned earlier.

To further try to implement security standards with this project, user passwords are not stored in plain text 
but salted and hashed using the [bcryptjs implementation](https://www.npmjs.com/package/bcryptjs).


Feel free to browse the database in a NoSQL client with the read-only credentials included in the submission.
